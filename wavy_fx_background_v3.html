<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Master Grid Interface – 50 Modes + Background Module</title>
<style>
  :root{ --bg:#0b0d12; --panel:#121725; --ink:#e6ecff; --muted:#99a7d1; --border:#1f2742; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid; grid-template-columns: 1fr 360px; grid-template-rows: 100vh}
  #stage{position:relative; background:#06080f}
  canvas{display:block; width:100%; height:100%; background:#000}
  aside{background:var(--panel); border-left:1px solid var(--border); padding:14px; overflow:auto}
  h1{margin:0 0 8px; font-size:16px}
  h2{margin:14px 0 6px; font-size:13px; color:var(--muted)}
  .row{display:flex; gap:8px; align-items:center; margin:6px 0}
  label{width:130px; color:var(--muted); font-size:12px}
  select,input[type="text"],input[type="number"],input[type="range"]{flex:1; background:#0f1424; color:var(--ink); border:1px solid var(--border); border-radius:9px; padding:6px 8px}
  input[type="range"]{padding:0}
  .btn{background:#0f1424; color:var(--ink); border:1px solid var(--border); border-radius:10px; padding:8px 10px; cursor:pointer}
  .btn:hover{border-color:#2b3760}
  .pill{display:inline-block; background:#0e1426; padding:2px 8px; border:1px solid #1b2447; border-radius:999px; margin:2px 6px 6px 0; font-size:12px; color:#cbd4ff}
  .two{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
  footer{margin-top:12px; color:var(--muted); font-size:11px}
</style>
</head>
<body>
<div class="wrap">
  <div id="stage"><canvas id="cv"></canvas></div>
  <aside>
    <h1>Master Grid Interface <small style="opacity:.6">(50 Modes + BG)</small></h1>
    <div class="pill">A / 0 = Master Randomize</div>
    <div class="pill">[ / ] = Prev/Next Mode</div>
    <div class="pill">1–7 = Module Randomizers</div>

    <!-- BACKGROUND MODULE -->
    <h2>Background <button class="btn" id="randBG" title="(7)">Randomize (7)</button></h2>
    <div class="row"><label><input type="checkbox" id="bgEnabled" checked> Enable Background</label></div>
    <div class="row"><label>BG Mode</label>
      <select id="bgMode">
        <option>Solid</option>
        <option>Soft Gradient</option>
        <option>Angular Gradient</option>
        <option>Vignette</option>
        <option>Noise Grain</option>
        <option>Paper Grain</option>
        <option>Geometric Tri</option>
        <option>Crosshatch</option>
        <option>Dots</option>
        <option>Diagonal Weave</option>
      </select>
    </div>
    <div class="two">
      <div class="row"><label>Opacity</label><input id="bgOpacity" type="range" min="0" max="1" step="0.01" value="0.9"></div>
      <div class="row"><label>Intensity</label><input id="bgIntensity" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    </div>
    <div class="two">
      <div class="row"><label>Pattern Scale</label><input id="bgScale" type="range" min="0.5" max="8" step="0.01" value="2.2"></div>
      <div class="row"><label>Anim Speed</label><input id="bgSpeed" type="range" min="0" max="2" step="0.01" value="0.35"></div>
    </div>
    <div class="row"><label><input id="bgLinkPalette" type="checkbox" checked> Link to Grid Palette</label></div>
    <div class="row"><label>BG Palette</label><select id="bgPalette"></select></div>

    <h2>Grid <button class="btn" id="randGrid" title="(1)">Randomize (1)</button></h2>
    <div class="row"><label>Mode</label><select id="gridMode"></select></div>
    <div class="row"><label>Cell Size</label><input id="cell" type="range" min="8" max="140" value="44" step="1"></div>
    <div class="two">
      <div class="row"><label>Stroke</label><input id="strokeW" type="range" min="0" max="4" step="0.1" value="1"></div>
      <div class="row"><label>Round</label><input id="round" type="range" min="0" max="0.5" step="0.01" value="0.1"></div>
    </div>
    <div class="two">
      <div class="row"><label>Jitter</label><input id="jitter" type="range" min="0" max="1" step="0.01" value="0"></div>
      <div class="row"><label>Rotation</label><input id="rot" type="range" min="-45" max="45" step="1" value="0"></div>
    </div>
    <div class="row"><label><input type="checkbox" id="drawLines" checked> Draw Cell Borders</label></div>

    <h2>Deform <button class="btn" id="randDeform" title="(2)">Randomize (2)</button></h2>
    <div class="two">
      <div class="row"><label>Wave</label><input id="wave" type="range" min="0" max="1.2" step="0.01" value="0.3"></div>
      <div class="row"><label>Wave Freq</label><input id="waveFreq" type="range" min="0" max="6" step="0.01" value="2.2"></div>
    </div>
    <div class="two">
      <div class="row"><label>Ripple</label><input id="ripple" type="range" min="0" max="1.2" step="0.01" value="0.2"></div>
      <div class="row"><label>Twist</label><input id="twist" type="range" min="-2" max="2" step="0.01" value="0.4"></div>
    </div>
    <div class="two">
      <div class="row"><label>Shear</label><input id="shear" type="range" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><label>Perspective</label><input id="persp" type="range" min="0" max="1" step="0.01" value="0.15"></div>
    </div>

    <h2>Color Module <button class="btn" id="randColor" title="(3)">Randomize (3)</button></h2>
    <div class="row"><label>Fill Mode</label><select id="fillMode"></select></div>
    <div class="row"><label>Opacity</label><input id="opacity" type="range" min="0" max="1" step="0.01" value="1"></div>
    <div class="row"><label>Palette</label><select id="palette"></select></div>
    <div class="row"><label><input id="lockPalette" type="checkbox"> Lock Palette</label></div>
    <div class="row"><label>Custom Hex</label><input id="custom" type="text" placeholder="#ff0066, #ffee00, #00ffcc"></div>
    <div class="row"><button class="btn" id="applyCustom">Apply Custom</button></div>

    <h2>Gradient <button class="btn" id="randGradient" title="(4)">Randomize (4)</button></h2>
    <div class="row"><label>Type</label><select id="gradType"><option value="linear">Linear</option><option value="radial">Radial</option><option value="angular">Angular</option></select></div>
    <div class="two">
      <div class="row"><label>Angle</label><input id="angle" type="range" min="0" max="360" step="1" value="30"></div>
      <div class="row"><label>Spread</label><input id="spread" type="range" min="0.2" max="4" step="0.01" value="1.1"></div>
    </div>

    <h2>Noise <button class="btn" id="randNoise" title="(5)">Randomize (5)</button></h2>
    <div class="two">
      <div class="row"><label>Scale</label><input id="noiseScale" type="range" min="0.002" max="0.05" step="0.001" value="0.012"></div>
      <div class="row"><label>Amount</label><input id="noiseAmt" type="range" min="0" max="1" step="0.01" value="0.65"></div>
    </div>
    <div class="row"><label>Drift Speed</label><input id="noiseSpeed" type="range" min="0" max="2" step="0.01" value="0.2"></div>

    <h2>Animation <button class="btn" id="randAnim" title="(6)">Randomize (6)</button></h2>
    <div class="row"><label><input id="animate" type="checkbox" checked> Animate</label></div>
    <div class="two">
      <div class="row"><label>Speed</label><input id="animSpeed" type="range" min="0" max="2" step="0.01" value="0.7"></div>
      <div class="row"><label><input id="hueCycle" type="checkbox"> Hue Cycle</label></div>
    </div>

    <div class="row" style="gap:8px; margin-top:10px">
      <button class="btn" id="randomize" title="(A / 0)">Master Randomize (A / 0)</button>
      <button class="btn" id="export">Export PNG</button>
    </div>

    <footer>Unified palettes ensure the grid + background stay in sync. BG textures/animations are lightweight so everything runs natively.</footer>
  </aside>
</div>
<script>
// ====== Small Utils ======
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const fract=v=>v-Math.floor(v);
function hexToRgb(hex){hex=hex.replace('#','').trim(); if(hex.length===3)hex=hex.split('').map(x=>x+x).join(''); const n=parseInt(hex,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return {h,s,l}};
function hslToRgb(h,s,l){const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p};let r,g,b;if(s===0){r=g=b=l;}else{const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return {r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)}}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
function makeValueNoise2D(seed=12345){const rand=mulberry32(seed);const perm=new Uint32Array(1024);for(let i=0;i<perm.length;i++)perm[i]=Math.floor(rand()*1e9);const hash=(x,y)=>{let h=perm[(x&1023)]^((perm[(y&1023)]<<13)|(perm[(y&1023)]>>>19));h=(h*1597334677)>>>0;return (h&0xffff)/0xffff};const s=t=>t*t*(3-2*t);return (x,y)=>{const xi=Math.floor(x),yi=Math.floor(y);const xf=x-xi,yf=y-yi;const v00=hash(xi,yi),v10=hash(xi+1,yi),v01=hash(xi,yi+1),v11=hash(xi+1,yi+1);const u=s(xf),v=s(yf);const x1=lerp(v00,v10,u),x2=lerp(v01,v11,u);return lerp(x1,x2,v)}}
class ColorRamp{constructor(colors){this.setColors(colors)} setColors(colors){this.colors=colors.map(c=>typeof c==="string"?hexToRgb(c):c);this.hsl=this.colors.map(c=>rgbToHsl(c.r,c.g,c.b))} get(t,hueShift=0,lightMul=1){t=clamp(t,0,1);const n=this.hsl.length;if(n===0)return 'rgb(255,255,255)'; if(n===1){let {h,s,l}=this.hsl[0];h=(h+hueShift)%1;if(h<0)h+=1;l=clamp(l*lightMul,0,1);const {r,g,b}=hslToRgb(h,s,l);return `rgb(${r},${g},${b})`;}const pos=t*(n-1);const i=Math.floor(pos);const f=pos-i;const a=this.hsl[i];const b=this.hsl[Math.min(i+1,n-1)];let dh=b.h-a.h; if(dh>0.5)dh-=1; if(dh<-0.5)dh+=1; let h=(a.h+dh*f+hueShift)%1;if(h<0)h+=1; const s=lerp(a.s,b.s,f); const l=clamp(lerp(a.l,b.l,f)*lightMul,0,1); const {r,g,b:bb}=hslToRgb(h,s,l); return `rgb(${r},${g},${bb})`}}

// ====== Palettes & Fill Modes ======
const PRESET_PALETTES={
  "Metro Neon":["#00f5d4","#00bbf9","#8338ec","#ff006e","#fb5607"],
  "Pastel Dream":["#ffd6e0","#e7c6ff","#caffbf","#fdffb6","#bde0fe"],
  "Sunset":["#120c31","#3a0ca3","#7209b7","#f72585","#ffba08"],
  "Ocean":["#001219","#005f73","#0a9396","#94d2bd","#e9d8a6"],
  "Forest":["#0b3d20","#14532d","1f6f43","#7aa874","#d1f5be"],
  "Candy":["#ffadad","#ffd6a5","#fdffb6","#caffbf","#9bf6ff"],
  "Mono Ink":["#0b0d12","#1a2236","#44506b","#9fb0d6","#e6ecff"],
  "Fire & Ice":["#00b4d8","#0077b6","#03045e","#ff6b6b","#ffd166"],
  "Solar":["#001219","#1b263b","#415a77","#e0fbfc","#fca311"],
  "Neon Synthwave":["#00e5ff","#ff3dff","#9b5de5","#f15bb5","#0a0a0a"],
  "Cyberpunk Tokyo":["#0affef","#ff0054","#7b2cbf","#00f5a0","#16161a"],
  "Desert Mirage":["#f1e0c5","#d9ae7e","#c56b2a","#b56576","#6b4f4f"],
  "Ocean Depths":["#a8dadc","#1d3557","#ff6f59","#2a9d8f","#264653"],
  "Sunset Fade":["#ff9e00","#fb5607","#8338ec","#3a0ca3","#001845"],
  "Ice & Fire":["#e0fbff","#a1d2ff","#457b9d","#ff5400","#ffb703"],
  "Jungle Vibe":["#004b23","#55a630","#aacc00","#ffd166","#6c584c"],
  "Aurora Borealis":["#1b3a4b","#0a9396","#8ecae6","#b5179e","#240046"],
  "Retro 80s Pastels":["#b8e0d2","#ffd6e0","#cce1ff","#e7c6ff","#fff3b0"],
  "Minimal Mono (Red)": ["#111111","#2b2b2b","#6c6c6c","#bfbfbf","#ff1b1c"],
  "Toxic Glow":["#00ff85","#caff00","#111111","#2f2f2f","#e6e6e6"],
  "Candy Pop":["#ff77aa","#ffea00","#6ecbff","#9d4edd","#ffffff"],
  "Lunar Glow":["#f4f1de","#e07a5f","#3d405b","#81b29a","#f2cc8f"],
  "Coral Reef":["#ff6f61","#ffb347","#6ec5e9","#005377","#f5f5f5"],
  "Midnight Garden":["#0d1b2a","#1b263b","#415a77","#778da9","#e0e1dd"],
  "Golden Hour":["#ffdd00","#ff8800","#ff3c00","#8c1c13","#2e1a1f"],
  "Arctic Frost":["#caf0f8","#90e0ef","#00b4d8","#0077b6","#03045e"],
  "Rose Quartz":["#f9dbbd","#fca3cc","#f15bb5","#9d4edd","#4a0e4e"],
  "Harvest Fields":["#f6bd60","#f7ede2","#f5cac3","#84a59d","#f28482"],
  "Electric Storm":["#2b2d42","#8d99ae","#edf2f4","#ef233c","#d90429"],
  "Deep Space":["#0b0033","#370031","#832161","#da4167","#f0eff4"],
  "Citrus Pop":["#fce762","#f68e5f","#f76c5e","#a23e48","#0b3954"],
  "Twilight Mist":["#f2e9e4","#c9ada7","#9a8c98","#4a4e69","#22223b"],
  "Festival Lights":["#ff1654","#ff9f1c","#2ec4b6","#00a896","#e0fbfc"],
  "Earth & Clay":["#7f5539","#9c6644","#ddb892","#e6ccb2","#ede0d4"],
  "Peacock Feathers":["#051923","#003554","#006494","#0582ca","#00a6fb"],
  "Molten Lava":["#590004","#800e13","#ad2831","#d8572a","#ffb627"],
  "Vintage Sepia":["#432818","#99582a","#bb9457","#ffe6a7","#e9d8a6"],
  "Aurora Twilight":["#03045e","#023e8a","#0077b6","#00b4d8","#90e0ef"],
  "Berry Crush":["#590d22","#800f2f","#a4133c","#ff4d6d","#ffccd5"],
  "Mystic Lagoon":["#14213d","#1d3557","#457b9d","#a8dadc","#f1faee"],
  "Solar Flare":["#ff5400","#ff6d00","#ff8500","#ff9100","#ffb300"]
};
const ColorModes=[
  'Solid','Alternating','Gradient – Linear','Gradient – Radial','Gradient – Angular','Noise – Hue','Noise – Brightness','Texture – Stripes','Rule – Mod 3',
  'Radial Burst Fill','Spiral Gradient Fill','Checkerboard Alternates','Waveband Fill','Voronoi Fill','Halftone Dots Fill','Glass Shard Fill','Stripe Overlay Fill','Concentric Rings Fill','Crosshatch Fill','Iridescent Fill','Metallic Sheen Fill','Glitch Strip Fill'
];

// 50 Grid Modes (names)
const GRID_MODES=['Square Grid','Rectangular Grid','Triangular Grid','Hexagonal Grid','Diamond Grid','Radial Grid','Polar Grid','Spiral Grid','Voronoi Grid (approx)','Delaunay Triangulation (approx)','Wave-Deformed Grid','Noise-Warped Grid','Ripple Grid','Twist Grid','Sheared Grid','Fractal Grid (recursive)','Isometric Grid','Cylindrical Grid','Spherical Grid','Tiling Grid (periodic)','Checkerboard Grid','Lattice Grid','Dot Matrix Grid','Organic Grid','Adaptive Grid','Pentagonal Grid (Cairo)','Octagon-Square Grid','Rhombille Grid','Kite-Dart (Penrose approx)','Quasi-Crystal (approx)','Perspective Grid','Fish-Eye Grid','Fractal Spiral Grid','Wave-Bend Grid','Swirl Grid','Honeycomb Rings','Cross-Hatch Grid','Dot-Lattice Grid','Checker-Warp Grid','Circle-Packing (approx)','Sliding Grid','Shattered Grid','Orbit Grid','Ripple-Propagated Grid','Jitter Grid','Recursive Subdivision','Hilbert Curve Grid','Hex-Pixel Grid','Randomized Grid','Adaptive Heatmap Grid'];

// ====== DOM ======
const ui={};
['bgEnabled','bgMode','bgOpacity','bgIntensity','bgScale','bgSpeed','bgLinkPalette','bgPalette','gridMode','cell','strokeW','round','jitter','rot','drawLines','wave','waveFreq','ripple','twist','shear','persp','fillMode','opacity','palette','lockPalette','custom','applyCustom','gradType','angle','spread','noiseScale','noiseAmt','noiseSpeed','animate','animSpeed','hueCycle','randomize','export','randGrid','randDeform','randColor','randGradient','randNoise','randAnim','randBG'].forEach(id=>ui[id]=document.getElementById(id));

// Populate selects
GRID_MODES.forEach((m,i)=>{const o=document.createElement('option');o.value=m;o.textContent=(i+1).toString().padStart(2,'0')+" – "+m;ui.gridMode.appendChild(o)}); ui.gridMode.value=GRID_MODES[0];
ColorModes.forEach(m=>{const o=document.createElement('option');o.value=m;o.textContent=m;ui.fillMode.appendChild(o)}); ui.fillMode.value='Gradient – Linear';
Object.keys(PRESET_PALETTES).forEach((k,i)=>{const o=document.createElement('option');o.value=k;o.textContent=k;if(i===0)o.selected=true;ui.palette.appendChild(o)});
Object.keys(PRESET_PALETTES).forEach((k,i)=>{const o=document.createElement('option');o.value=k;o.textContent=k;if(i===0)o.selected=true;ui.bgPalette.appendChild(o)});

// ====== State ======
const canvas=document.getElementById('cv'); const ctx=canvas.getContext('2d');
let dpr=1; function resize(){dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1)); const w=document.getElementById('stage').clientWidth; const h=document.getElementById('stage').clientHeight; canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr); canvas.style.width=w+'px'; canvas.style.height=h+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);} window.addEventListener('resize',resize); resize();
const state={time:0, ramp:new ColorRamp(PRESET_PALETTES[ui.palette.value]), bgRamp:new ColorRamp(PRESET_PALETTES[ui.bgPalette.value]), noise:makeValueNoise2D(((Math.random()*1e9)|0))};

function setPalette(key){state.ramp.setColors(PRESET_PALETTES[key])}
function setBGPalette(key){state.bgRamp.setColors(PRESET_PALETTES[key])}

// ====== Color Module: get fill color for cell ======
function projectLinear(nx,ny,angle,spread){const c=Math.cos(angle),s=Math.sin(angle);return (nx*c+ny*s)*spread}
function colorForCell(nx,ny,row,col,idx,t){
  const mode=ui.fillMode.value; const opacity=parseFloat(ui.opacity.value); ctx.globalAlpha=opacity;
  const anim=parseFloat(ui.animSpeed.value)*(ui.animate.checked?1:0); const hueShift=ui.hueCycle.checked? (0.15*Math.sin(t*anim*0.9)):0; const breathMul=1;
  let color='rgb(255,255,255)';
  if(mode==='Solid'){ color=state.ramp.get(0.5,hueShift,breathMul); }
  else if(mode==='Alternating'){ const n=state.ramp.hsl.length; const ti=n<=1?0.5: ((row+col)%n)/(n-1); color=state.ramp.get(ti,hueShift,breathMul); }
  else if(mode.startsWith('Gradient')){
    const type=ui.gradType.value; const s=parseFloat(ui.spread.value); const ang=(parseFloat(ui.angle.value)*Math.PI/180);
    if(type==='linear'){
      const p=projectLinear(nx-0.5,ny-0.5,ang,s); const tLin=clamp(p*0.5+0.5,0,1); color=state.ramp.get(tLin,hueShift,breathMul);
    } else if(type==='radial'){
      const dx=nx-0.5, dy=ny-0.5; const d=Math.sqrt(dx*dx+dy*dy)*s; color=state.ramp.get(clamp(d*1.5,0,1),hueShift,breathMul);
    } else { // angular
      const a=Math.atan2(ny-0.5,nx-0.5); const tAng=((a/Math.PI)+1)/2; const tWrap=fract(tAng*s); color=state.ramp.get(tWrap,hueShift,breathMul);
    }
  }
  else if(mode==='Noise – Hue' || mode==='Noise – Brightness'){
    const scale=parseFloat(ui.noiseScale.value), amount=parseFloat(ui.noiseAmt.value), drift=parseFloat(ui.noiseSpeed.value); const n=state.noise(nx/scale+ state.time*drift, ny/scale + 17.3);
    const base=(mode==='Noise – Hue')? ((row+col)%2?0.7:0.3):0.5; const tn=clamp(n*amount+(1-amount)*base,0,1); color=state.ramp.get(tn,hueShift,breathMul);
  }
  else if(mode==='Texture – Stripes'){
    const ang=(parseFloat(ui.angle.value)*Math.PI/180); const freq=parseFloat(ui.spread.value)*10; const p=projectLinear(nx,ny,ang,freq); const s0=Math.sin(p*2*Math.PI + state.time*0.8); color=state.ramp.get(s0*0.5+0.5,hueShift,breathMul);
  }
  else if(mode==='Rule – Mod 3'){ const seq=[0.1,0.5,0.9]; color=state.ramp.get(seq[idx%3],hueShift,breathMul); }
  else if(mode==='Radial Burst Fill'){
    const k=5; let minD=1e9; for(let i=0;i<k;i++){ const cx=fract(0.37*i+0.13)*0.8+0.1; const cy=fract(0.61*i+0.27)*0.8+0.1; const d=Math.hypot(nx-cx,ny-cy); if(d<minD) minD=d; }
    const tR=clamp(1.2-minD*parseFloat(ui.spread.value)*3,0,1); color=state.ramp.get(tR,hueShift,breathMul);
  }
  else if(mode==='Spiral Gradient Fill'){
    const cx=0.5, cy=0.5; const dx=nx-cx, dy=ny-cy; const r=Math.hypot(dx,dy); const theta=Math.atan2(dy,dx); const k=0.6*parseFloat(ui.spread.value); const tS=fract(theta/(2*Math.PI) + r*k + state.time*0.05); color=state.ramp.get(tS,hueShift,breathMul);
  }
  else if(mode==='Checkerboard Alternates'){
    const v=((row^col)&1)?0.15:0.85; color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Waveband Fill'){
    const freq=3.0*parseFloat(ui.spread.value); const v=Math.sin((ny+0.15)*freq*2*Math.PI + state.time*0.7); color=state.ramp.get(v*0.5+0.5,hueShift,breathMul);
  }
  else if(mode==='Voronoi Fill'){
    const scale=3*parseFloat(ui.spread.value)+2; const gx=nx*scale, gy=ny*scale; const ix=Math.floor(gx), iy=Math.floor(gy); let md=1e9; for(let j=-1;j<=1;j++) for(let i=-1;i<=1;i++){ const px=ix+i+fract(Math.sin((ix+i)*127.1+(iy+j)*311.7)*43758.5453); const py=iy+j+fract(Math.sin((ix+i)*269.5+(iy+j)*183.3)*96858.33); const d=Math.hypot(gx-px,gy-py); if(d<md) md=d; }
    const v=clamp(1-md,0,1); color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Halftone Dots Fill'){
    const freq=8*parseFloat(ui.spread.value); const gx=nx*freq, gy=ny*freq; const dx=gx-Math.round(gx); const dy=gy-Math.round(gy); const d=Math.hypot(dx,dy); const v=clamp(1-d*2,0,1); color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Glass Shard Fill'){
    const a=Math.atan2(ny-0.5,nx-0.5); const q=Math.floor(((a+Math.PI)/(2*Math.PI))*12*parseFloat(ui.spread.value)); const v=fract(q*0.173+ (nx+ny)*0.37 ); color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Stripe Overlay Fill'){
    const base=clamp(projectLinear(nx-0.5,ny-0.5,0,parseFloat(ui.spread.value))*0.5+0.5,0,1); const stripes=fract(nx*parseFloat(ui.spread.value)*3 + state.time*0.6) < 0.5 ? 0.2:0.8; const v=clamp(base*0.7 + stripes*0.3,0,1); color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Concentric Rings Fill'){
    const d=Math.hypot(nx-0.5,ny-0.5); const bands=Math.max(1, parseFloat(ui.spread.value)*8); const v=fract(d*bands); color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Crosshatch Fill'){
    const f=parseFloat(ui.spread.value)*10; const s1=fract((nx+ny)*f); const s2=fract((nx-ny)*f); const v=clamp((s1<0.5?0.2:0.8)*0.5 + (s2<0.5?0.2:0.8)*0.5,0,1); color=state.ramp.get(v,hueShift,breathMul);
  }
  else if(mode==='Iridescent Fill'){
    const a=Math.atan2(ny-0.5,nx-0.5); const v=fract(a/(2*Math.PI) + 0.15*Math.sin(state.time*0.6)); color=state.ramp.get(v,hueShift+0.2,breathMul);
  }
  else if(mode==='Metallic Sheen Fill'){
    const ang=(parseFloat(ui.angle.value)*Math.PI/180); const p=projectLinear(nx-0.5,ny-0.5,ang,4); const v=clamp(0.5+0.5*Math.cos(p*2*Math.PI),0,1); const sharp=Math.pow(v,3); color=state.ramp.get(sharp,hueShift,breathMul*1.1);
  }
  else if(mode==='Glitch Strip Fill'){
    const bands=Math.floor(ny*40); const jump=fract(Math.sin(bands*12.9898)*43758.5453); const v=clamp(fract(nx*parseFloat(ui.spread.value)*3 + jump*2),0,1); color=state.ramp.get(v,hueShift,breathMul);
  }
  else { const seq=[0.1,0.5,0.9]; color=state.ramp.get(seq[idx%3],hueShift,breathMul); }
  return color;
}

// ====== Background Rendering ======
function drawBackground(w,h,t){
  if(!ui.bgEnabled.checked){return;}
  const speed=parseFloat(ui.bgSpeed.value);
  const op=parseFloat(ui.bgOpacity.value);
  const sc=Math.max(0.0001, parseFloat(ui.bgScale.value));
  const k=parseFloat(ui.bgIntensity.value);
  const ramp = (ui.bgLinkPalette.checked ? state.ramp : state.bgRamp);
  const mode = ui.bgMode.value;
  ctx.save();
  ctx.globalAlpha = op;

  // helpers
  const fillRectColor=(col)=>{ctx.fillStyle=col;ctx.fillRect(0,0,w,h)}
  const gradLinear=(ang)=>{const g=ctx.createLinearGradient(0,0,w,h); const steps=6; for(let i=0;i<=steps;i++){const tt=i/steps; const c=ramp.get(tt, 0.08*Math.sin(t*speed), 1); g.addColorStop(tt,c);} return g}
  const gradRadial=()=>{const g=ctx.createRadialGradient(w*0.5,h*0.5,0,w*0.5,h*0.5,Math.hypot(w,h)*0.6); const steps=6; for(let i=0;i<=steps;i++){const tt=i/steps; g.addColorStop(tt, ramp.get(tt, 0.1*Math.sin(t*speed*0.8), 1)); } return g}

  if(mode==='Solid'){
    fillRectColor(ramp.get(0.5,0,1));
  }
  else if(mode==='Soft Gradient'){
    ctx.fillStyle=gradLinear(t*0.1);
    ctx.fillRect(0,0,w,h);
  }
  else if(mode==='Angular Gradient'){
    ctx.fillStyle=gradLinear(t*speed*2.0);
    ctx.fillRect(0,0,w,h);
  }
  else if(mode==='Vignette'){
    // base
    ctx.fillStyle=gradRadial();
    ctx.fillRect(0,0,w,h);
    // vignette darken edges using multiply-like effect
    const g=ctx.createRadialGradient(w*0.5,h*0.5,Math.min(w,h)*0.15,w*0.5,h*0.5,Math.hypot(w,h)*0.7);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,'+(0.35*k+0.05)+')');
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  }
  else if(mode==='Noise Grain' || mode==='Paper Grain'){
    const ns=makeValueNoise2D(123456);
    const cell=8; // coarse blocks for speed
    for(let y=0;y<h;y+=cell){
      for(let x=0;x<w;x+=cell){
        const nx=x/(cell*sc), ny=y/(cell*sc);
        let n=ns(nx+ t*speed*0.5, ny+ 31.7);
        if(mode==='Paper Grain'){ n = Math.pow(n, 1.5); }
        const v = clamp(n*0.9+0.05,0,1);
        ctx.fillStyle=ramp.get(v, 0.0, 1);
        ctx.fillRect(x,y,cell,cell);
      }
    }
  }
  else if(mode==='Geometric Tri'){
    const s= Math.max(24, 80/sc);
    for(let y=-s;y<h+s;y+=s){
      for(let x=-s;x<w+s;x+=s){
        const v=fract((x+y)*0.002 + 0.1*Math.sin((x*0.01+y*0.008)+t*speed));
        const c=ramp.get(v, 0.0, 1);
        ctx.beginPath();
        if(((x+y)/s)&1){ctx.moveTo(x,y);ctx.lineTo(x+s,y);ctx.lineTo(x,y+s);} else {ctx.moveTo(x+s,y);ctx.lineTo(x+s,y+s);ctx.lineTo(x,y+s);} 
        ctx.closePath(); ctx.fillStyle=c; ctx.fill();
      }
    }
  }
  else if(mode==='Crosshatch'){
    fillRectColor(ramp.get(0.45,0,1));
    const f=8/sc; ctx.globalAlpha = op*0.5*k+0.2;
    ctx.beginPath();
    for(let y=0;y<h;y+=f){ ctx.moveTo(0,y + (Math.sin((y*0.02)+t*speed)*2)); ctx.lineTo(w,y + (Math.sin((y*0.02)+t*speed)*2)); }
    for(let x=0;x<w;x+=f){ ctx.moveTo(x + (Math.cos((x*0.02)+t*speed)*2),0); ctx.lineTo(x + (Math.cos((x*0.02)+t*speed)*2),h); }
    ctx.strokeStyle='rgba(0,0,0,'+(0.15*k+0.05)+')'; ctx.lineWidth=1; ctx.stroke();
  }
  else if(mode==='Dots'){
    const s= Math.max(6, 28/sc);
    for(let y=0;y<h;y+=s){
      for(let x=0;x<w;x+=s){
        const a=fract((x*0.83+y*0.37)*0.005 + t*speed*0.1);
        ctx.fillStyle=ramp.get(a, 0, 1);
        ctx.beginPath(); ctx.arc(x+0.5*s,y+0.5*s,(s*0.22)*(0.5+0.5*Math.sin(a*6.283+ t*speed)),0,Math.PI*2); ctx.fill();
      }
    }
  }
  else if(mode==='Diagonal Weave'){
    const s= Math.max(10, 40/sc);
    for(let y=-s;y<h+s;y+=s){
      for(let x=-s;x<w+s;x+=s){
        const u = (x+y)/(w+h); const c=ramp.get(fract(u + 0.15*Math.sin(t*speed)), 0, 1);
        ctx.fillStyle=c; ctx.fillRect(x,y,s*0.7,s*0.7);
      }
    }
  }
  ctx.restore();
}

// ====== Drawing Helpers ======
function pathRoundedRect(x,y,w,h,r){r=Math.min(r,Math.min(w,h)/2); ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);} 
function drawHex(cx,cy,r){const a=Math.PI/3; ctx.beginPath(); for(let i=0;i<6;i++){const th=a*i; const px=cx+r*Math.cos(th), py=cy+r*Math.sin(th); i?ctx.lineTo(px,py):ctx.moveTo(px,py);} ctx.closePath();}
function drawTriangle(cx,cy,s,flip){const h=s*Math.sqrt(3)/2; ctx.beginPath(); if(!flip){ ctx.moveTo(cx,cy-h/2); ctx.lineTo(cx-s/2,cy+h/2); ctx.lineTo(cx+s/2,cy+h/2);} else { ctx.moveTo(cx,cy+h/2); ctx.lineTo(cx-s/2,cy-h/2); ctx.lineTo(cx+s/2,cy-h/2);} ctx.closePath();}

// Deformers
function applyDeforms(x,y,w,h,t){
  const nx=x/w, ny=y/h; const cx=nx-0.5, cy=ny-0.5; let dx=0,dy=0;
  const wav=parseFloat(ui.wave.value), wf=parseFloat(ui.waveFreq.value); if(wav>0){ dx+=Math.sin((ny*wf*2*Math.PI)+t)*wav*10; dy+=Math.cos((nx*wf*2*Math.PI)-t*0.7)*wav*10; }
  const rp=parseFloat(ui.ripple.value); if(rp>0){ const d=Math.hypot(cx,cy); const s=Math.sin(d*20 - t*2)*rp*12; dx+= (cx/(d+1e-4))*s; dy+=(cy/(d+1e-4))*s; }
  const tw=parseFloat(ui.twist.value); if(Math.abs(tw)>0.001){ const ang=tw*(Math.hypot(cx,cy))*2; const cos=Math.cos(ang), sin=Math.sin(ang); const rx=cx*cos - cy*sin; const ry=cx*sin + cy*cos; dx+=(rx-cx)*w; dy+=(ry-cy)*h; }
  const sh=parseFloat(ui.shear.value); if(Math.abs(sh)>0.001){ dx+= (ny-0.5)*sh*80; }
  const p=parseFloat(ui.persp.value); if(p>0){ const m=lerp(1, 0.5, Math.abs(ny-0.5)*2*p); dy+= (1-m)* (ny-0.5)*h; }
  return {dx,dy};
}

// ====== Core Render ======
function draw(){
  const w=canvas.width/dpr, h=canvas.height/dpr; ctx.clearRect(0,0,w,h);
  const mode=ui.gridMode.value; const cell=parseInt(ui.cell.value,10); const stroke=parseFloat(ui.strokeW.value); const round=parseFloat(ui.round.value); const jitter=parseFloat(ui.jitter.value); const rot=parseFloat(ui.rot.value)*Math.PI/180; const t=state.time;

  // --- BACKGROUND FIRST ---
  drawBackground(w,h,t);

  // --- GRID ---
  ctx.save(); ctx.translate(w/2,h/2); ctx.rotate(rot); ctx.translate(-w/2,-h/2);
  const drawStroke=ui.drawLines.checked; ctx.lineWidth=stroke; ctx.strokeStyle='rgba(25,35,60,0.7)';

  if(mode==='Hexagonal Grid' || mode==='Honeycomb Rings' || mode==='Hex-Pixel Grid'){
    const r=cell*0.5; const dx=r*Math.sqrt(3); const dy=r*1.5; const cols=Math.ceil(w/dx)+2; const rows=Math.ceil(h/dy)+2;
    for(let rI=0;rI<rows;rI++){
      for(let cI=0;cI<cols;cI++){
        let cx=cI*dx + ((rI%2)? dx/2 : 0); let cy=rI*dy; const disp=applyDeforms(cx,cy,w,h,t); cx+=disp.dx; cy+=disp.dy;
        drawHex(cx,cy,r*0.95);
        const col=colorForCell(cx/w,cy/h,rI,cI,rI*cols+cI,t); ctx.fillStyle=col; ctx.fill(); if(drawStroke){ctx.stroke();}
      }
    }
  }
  else {
    const cols=Math.ceil(w/cell)+2, rows=Math.ceil(h/cell)+2;
    for(let rI=0;rI<rows;rI++){
      for(let cI=0;cI<cols;cI++){
        let x=cI*cell, y=rI*cell;
        if(mode==='Diamond Grid'){ y+= (cI%2)*cell*0.5; }
        if(mode==='Triangular Grid' || mode==='Rhombille Grid' || mode==='Cross-Hatch Grid'){ x+= (rI%2)*cell*0.5; }
        if(mode==='Sliding Grid'){ x+= Math.sin((rI*0.3)+t)*cell*0.3; }
        if(mode==='Shattered Grid'){ x+= (Math.sin(rI*12.345+cI)*0.5)*cell*0.2; y+= (Math.cos(cI*9.87+rI)*0.5)*cell*0.2; }
        if(mode==='Orbit Grid'){ const a=t*0.4 + (rI+cI)*0.05; x+=Math.cos(a)*10; y+=Math.sin(a)*10; }
        if(mode==='Jitter Grid'){ x+= (Math.random()-0.5)*cell*0.1*jitter; y+= (Math.random()-0.5)*cell*0.1*jitter; }

        const disp=applyDeforms(x+cell*0.5,y+cell*0.5,w,h,t); x+=disp.dx; y+=disp.dy;
        const cx=x+cell*0.5, cy=y+cell*0.5;
        const nx=cx/w, ny=cy/h;
        const color=colorForCell(nx,ny,rI,cI,rI*cols+cI,t); ctx.fillStyle=color;

        if(['Dot Matrix Grid','Dot-Lattice Grid','Circle-Packing (approx)','Adaptive Heatmap Grid'].includes(mode)){
          let rad = cell*0.35;
          if(['Circle-Packing (approx)','Adaptive Heatmap Grid'].includes(mode)){
            const n=state.noise(nx/parseFloat(ui.noiseScale.value), ny/parseFloat(ui.noiseScale.value));
            rad = lerp(cell*0.12, cell*0.48, n);
          }
          ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Triangular Grid','Rhombille Grid'].includes(mode)){
          const flip=((rI+cI)%2)===0; drawTriangle(cx,cy,cell*0.95,flip); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Checkerboard Grid','Checker-Warp Grid'].includes(mode)){
          const rr = (mode==='Checker-Warp Grid')? cell* (1+0.3*Math.sin((nx+ny+t)*4)) : cell;
          pathRoundedRect(cx-rr/2, cy-rr/2, rr*0.98, rr*0.98, round*rr); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Lattice Grid','Cross-Hatch Grid'].includes(mode)){
          ctx.fillStyle='rgba(255,255,255,0.02)'; pathRoundedRect(cx-cell/2,cy-cell/2,cell,cell,round*cell); ctx.fill(); if(drawStroke){ctx.stroke();}
          ctx.beginPath(); ctx.moveTo(cx-cell/2,cy); ctx.lineTo(cx+cell/2,cy); ctx.moveTo(cx,cy-cell/2); ctx.lineTo(cx,cy+cell/2); ctx.stroke();
        }
        else if(mode==='Isometric Grid'){
          pathRoundedRect(cx-cell*0.5,cy-cell*0.5,cell,cell,round*cell); ctx.save(); ctx.translate(cx,cy); ctx.rotate(Math.PI/4); ctx.translate(-cx,-cy); ctx.fill(); if(drawStroke){ctx.stroke();} ctx.restore();
        }
        else if(mode==='Octagon-Square Grid'){
          const s=cell*0.9; const k=s*0.22; ctx.beginPath();
          ctx.moveTo(cx-s/2+k,cy-s/2); ctx.lineTo(cx+s/2-k,cy-s/2); ctx.lineTo(cx+s/2,cy-s/2+k); ctx.lineTo(cx+s/2,cy+s/2-k); ctx.lineTo(cx+s/2-k,cy+s/2); ctx.lineTo(cx-s/2+k,cy+s/2); ctx.lineTo(cx-s/2,cy+s/2-k); ctx.lineTo(cx-s/2,cy-s/2+k); ctx.closePath(); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(mode==='Pentagonal Grid (Cairo)'){
          const s=cell*0.9; const a=Math.PI*2/5; const r=s*0.42; ctx.beginPath(); for(let i=0;i<5;i++){const th=i*a - Math.PI/2; const px=cx+r*Math.cos(th), py=cy+r*Math.sin(th); i?ctx.lineTo(px,py):ctx.moveTo(px,py);} ctx.closePath(); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Wave-Deformed Grid','Wave-Bend Grid','Swirl Grid','Twist Grid','Sheared Grid','Perspective Grid','Fish-Eye Grid','Cylindrical Grid','Spherical Grid','Polar Grid','Radial Grid','Spiral Grid','Fractal Spiral Grid','Orbit Grid','Ripple-Propagated Grid','Ripple Grid'].includes(mode)){
          pathRoundedRect(cx-cell/2,cy-cell/2,cell*0.98,cell*0.98,round*cell); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Noise-Warped Grid','Organic Grid','Randomized Grid'].includes(mode)){
          const n=state.noise(nx/parseFloat(ui.noiseScale.value), ny/parseFloat(ui.noiseScale.value)); const s=lerp(cell*0.6, cell*1.1, n);
          pathRoundedRect(cx-s/2, cy-s/2, s*0.98, s*0.98, round*s); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Recursive Subdivision','Fractal Grid (recursive)'].includes(mode)){
          const half=cell*0.5; const choose=((rI+cI)&1)===0; if(choose){ for(let yy=-0.25; yy<=0.25; yy+=0.5){ for(let xx=-0.25; xx<=0.25; xx+=0.5){ pathRoundedRect(cx+xx*cell, cy+yy*cell, half*0.9, half*0.9, round*half); ctx.fill(); if(drawStroke){ctx.stroke();} }} } else { pathRoundedRect(cx-cell/2,cy-cell/2,cell*0.98,cell*0.98,round*cell); ctx.fill(); if(drawStroke){ctx.stroke();} }
        }
        else if(mode==='Hilbert Curve Grid'){
          const n=state.noise(nx*20,ny*20); const s=lerp(cell*0.5,cell, n);
          pathRoundedRect(cx-s/2,cy-s/2,s*0.98,s*0.98,round*s); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
        else if(['Delaunay Triangulation (approx)','Voronoi Grid (approx)','Quasi-Crystal (approx)','Kite-Dart (Penrose approx)','Tiling Grid (periodic)'].includes(mode)){
          const n=state.noise(nx/parseFloat(ui.noiseScale.value), ny/parseFloat(ui.noiseScale.value)); const s=lerp(cell*0.6, cell*1.0, n);
          ctx.save(); ctx.translate(cx,cy); ctx.rotate(n*Math.PI*2); pathRoundedRect(-s/2,-s/2,s*0.98,s*0.98,round*s); ctx.fill(); if(drawStroke){ctx.stroke();} ctx.restore();
        }
        else {
          pathRoundedRect(cx-cell/2,cy-cell/2,cell*0.98,cell*0.98,round*cell); ctx.fill(); if(drawStroke){ctx.stroke();}
        }
      }
    }
  }
  ctx.restore();
}

// ====== Animation Loop ======
let last=0; function loop(now){const dt=(now-last)||16; last=now; if(ui.animate.checked){ state.time+=dt/1000; } draw(); requestAnimationFrame(loop)} requestAnimationFrame(loop);

// ====== Randomizers ======
function randomChoice(arr){return arr[(Math.random()*arr.length)|0]}
function randomIn(min,max,dec=0){const v=min+Math.random()*(max-min); return dec? v.toFixed(dec): Math.round(v)}

function randomizeBG(){
  ui.bgEnabled.checked = Math.random() > 0.05;
  ui.bgMode.value = randomChoice(["Solid","Soft Gradient","Angular Gradient","Vignette","Noise Grain","Paper Grain","Geometric Tri","Crosshatch","Dots","Diagonal Weave"]);
  ui.bgOpacity.value = (Math.random()*0.5+0.4).toFixed(2);
  ui.bgIntensity.value = Math.random().toFixed(2);
  ui.bgScale.value = (Math.random()*7.5+0.5).toFixed(2);
  ui.bgSpeed.value = (Math.random()*1.5).toFixed(2);
  ui.bgLinkPalette.checked = Math.random()>0.35;
  if(!ui.bgLinkPalette.checked){ ui.bgPalette.value = randomChoice(Object.keys(PRESET_PALETTES)); setBGPalette(ui.bgPalette.value); }
  draw();
}
function randomizeGrid(){ ui.gridMode.value = randomChoice(GRID_MODES); ui.cell.value = randomIn(12,112); ui.strokeW.value = (Math.random()*2.5).toFixed(1); ui.round.value = (Math.random()*0.5).toFixed(2); ui.jitter.value = Math.random().toFixed(2); ui.rot.value = randomIn(-45,45); ui.drawLines.checked = Math.random()>0.3; draw(); }
function randomizeDeform(){ ui.wave.value=(Math.random()*1.2).toFixed(2); ui.waveFreq.value=(Math.random()*6).toFixed(2); ui.ripple.value=(Math.random()*1.2).toFixed(2); ui.twist.value=((Math.random()*4)-2).toFixed(2); ui.shear.value=((Math.random()*2)-1).toFixed(2); ui.persp.value=(Math.random()).toFixed(2); draw(); }
function randomizeColor(){ ui.fillMode.value = randomChoice(ColorModes); if(!ui.lockPalette.checked){ const keys=Object.keys(PRESET_PALETTES); const k=randomChoice(keys); ui.palette.value=k; setPalette(k);} else { setPalette(ui.palette.value); } ui.opacity.value=(Math.random()*0.6+0.4).toFixed(2); if(ui.bgLinkPalette.checked){ setBGPalette(ui.palette.value); } draw(); }
function randomizeGradient(){ ui.gradType.value=randomChoice(['linear','radial','angular']); ui.angle.value=randomIn(0,360); ui.spread.value=(Math.random()*3+0.2).toFixed(2); draw(); }
function randomizeNoise(){ ui.noiseScale.value=(Math.random()*0.04+0.005).toFixed(3); ui.noiseAmt.value=Math.random().toFixed(2); ui.noiseSpeed.value=(Math.random()*1.2).toFixed(2); draw(); }
function randomizeAnim(){ ui.animate.checked=true; ui.animSpeed.value=(Math.random()*1.4+0.2).toFixed(2); ui.hueCycle.checked=Math.random()>0.5; draw(); }
function masterRandomize(){ randomizeBG(); randomizeGrid(); randomizeDeform(); randomizeColor(); randomizeGradient(); randomizeNoise(); randomizeAnim(); }

// ====== Wiring ======
['bgEnabled','bgMode','bgOpacity','bgIntensity','bgScale','bgSpeed','bgLinkPalette','bgPalette','gridMode','cell','strokeW','round','jitter','rot','drawLines','wave','waveFreq','ripple','twist','shear','persp','fillMode','opacity','palette','gradType','angle','spread','noiseScale','noiseAmt','noiseSpeed','animate','animSpeed','hueCycle'].forEach(id=> ui[id].addEventListener('input',()=>{ if(id==='palette' && ui.bgLinkPalette.checked){ setBGPalette(ui.palette.value); } draw(); }));
ui.applyCustom.addEventListener('click',()=>{const raw=ui.custom.value.trim(); if(!raw)return; const parts=raw.split(/[\s,]+/).filter(Boolean); try{ state.ramp.setColors(parts); ui.lockPalette.checked=true; if(ui.bgLinkPalette.checked){ setBGPaletteFromRamp(); } draw(); }catch(e){ alert('Use comma-separated hex like #ff0066, #ffee00'); }});
ui.bgPalette.addEventListener('change',()=>{ setBGPalette(ui.bgPalette.value); draw(); });
ui.palette.addEventListener('change',()=>{ setPalette(ui.palette.value); if(ui.bgLinkPalette.checked){ setBGPalette(ui.palette.value); } draw(); });

// Buttons
ui.randBG.addEventListener('click',randomizeBG);
ui.randGrid.addEventListener('click',randomizeGrid);
ui.randDeform.addEventListener('click',randomizeDeform);
ui.randColor.addEventListener('click',randomizeColor);
ui.randGradient.addEventListener('click',randomizeGradient);
ui.randNoise.addEventListener('click',randomizeNoise);
ui.randAnim.addEventListener('click',randomizeAnim);
ui.randomize.addEventListener('click',masterRandomize);
ui.export.addEventListener('click',()=>{const link=document.createElement('a'); link.download='grid-50-modes-bg.png'; link.href=canvas.toDataURL('image/png'); link.click();});

// Keyboard
window.addEventListener('keydown',(e)=>{
  if(e.key==='A' || e.key==='a' || e.key==='0'){ masterRandomize(); }
  else if(e.key===']'){ stepMode(1); }
  else if(e.key==='['){ stepMode(-1);} 
  else if(e.key==='1'){ randomizeGrid(); }
  else if(e.key==='2'){ randomizeDeform(); }
  else if(e.key==='3'){ randomizeColor(); }
  else if(e.key==='4'){ randomizeGradient(); }
  else if(e.key==='5'){ randomizeNoise(); }
  else if(e.key==='6'){ randomizeAnim(); }
  else if(e.key==='7'){ randomizeBG(); }
});

function stepMode(dir){ const i=GRID_MODES.indexOf(ui.gridMode.value); const j=(i+dir+GRID_MODES.length)%GRID_MODES.length; ui.gridMode.value=GRID_MODES[j]; draw(); }

// initial paint
setPalette(ui.palette.value); setBGPalette(ui.bgLinkPalette.checked? ui.palette.value : ui.bgPalette.value); draw();
</script>
</body>
</html>
